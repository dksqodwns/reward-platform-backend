# 설계하며 고민한 내용

## 서버 통신 방식

### gRPC vs TCP vs 메시지큐
  - 중복 요청에 대한 검증을 요청 단에서 한번 더 막으려면 메시지 큐를 통해 요청 - 응답을 관리하는게 좋을 것 같지만, 조금 더 빠른 응답을 위해 gRPC, TCP 중에서 선택 하기로 함
  - gRPC가 TCP에 비해 장점이 많지만, 목적이 이벤트를 관리 및 유저의 보상 요청 처리에 있으므로, TCP로 구현해도 무방하다고 판단함
  - 추후, 오고 가야하는 데이터의 양이 많아지거나 retry등의 요구사항이 생기면 gRPC로 전환하는 것으로 계획

## JWT
### AccessToken 관리
  - 서버 메모리에 저장해서 관리하는게 좋을 것 같지만, 분산 환경일 경우에는 정보가 공유되지 않을 수 있음
  - `Redis`를 사용하기에는 오버 엔지니어링이라고 판단
  - `AccessToken`의 만료 기간을 짧게 만들어서 `RefreshToken`을 통한 재발급 로직을 탈 수 있도록 함
  - 강제 로그아웃같은 기능을 구현하려면 유저의 RefreshToken 값을 만료시키는 것으로 가능

## 이벤트
중복 요청에 대한 고민
1. 유저가 이벤트에 대한 보상을 요청하면 ‘유저 아이디’ - ‘이벤트 아이디’가 쌍으로 묶여있는 데이터가 보상 대기 큐에 들어감
2. 큐의 순서가 되면
  1. DB (mongodb)에 rwlock을 걸고, userEvent 컬렉션에 해당하는 요청이 있었는지 조회함
  2. 있으면
    1. 409 에러를 냄
  3. 없으면
    1. userEvent 컬렉션에 데이터를 추가하고, 이벤트의 보상을 리턴함

여기서 고민이 되는것은
1. 분산 환경의 경우, 큐가 공유되지 않을텐데 어떻게 할 것인지?
- 레디스를 사용해서 공유되는 저장 공간을 확보한다.
2. 수많은 유저의 요청이 있을 경우에는 db write 작업이 많아져서 병목이 생기텐데?
- 이건 어떻게 해야 할지 모르겠음….


고안한 해결 방법
1. 유저 보상 요청이 비교적 적은 시간대 혹은, 기간일 경우
  1. user_events 컬렉션에 유니크 인덱스를 걸어, 동일한 (userId, eventKey)가 insert를 시도하면 11000 duplicate key error를 내도록 함
  2. insert가 성공하면 보상 지급 로직을 수행하고, 실패하면 409 에러를 냄
2. 유저 보상 요청이 비교적 잦은 시간대 혹은, 기간일 경우
  1. DB 샤딩
    1. DB를 여러 서버에 나누어 저장하여, eventKey가 A인 레코드는 샤드 A에, B인 레코드는 샤드 B에 저장하는 식으로 처리하여, 부하를 분산시킨다.
  2. 컬렉션 분할
    1. 이벤트, 혹은 시간별로 컬렉션을 분할하여 데이터를 저장한다. (예, user_events_event_A 혹은 user_event_20250518)
  3. 메시지 큐 적용
    1. 유저의 보상 요청을 Redis와 같은 분산 환경에서도 공유 할 수 있는 저장소에 저장하고, 중복된 데이터 삽입을 막는다.
    2. 1분마다 배치로 저장소에 적재되어있는 요청을 한번에 처리한다. 
    - 샤딩의 경우는 여러대의 서버가 필요하지만, 대규모 클러스터에 적합 할 것이고, 컬렉션 분할의 경우 인프라 변경 없이 어플리케이션 레벨에서 적용이 가능하다.
  4. 이벤트 조건을 충족시킨 유저를 따로 빼서 테이블에 추가해놓음



# 구현해야 하는 것

- 로그인 시 리프레시 토큰 발급 -> 같은 기기에 할당된 데이터가 이미 있고, 살아있으면 발급 X
- filter 기능 roles 잘 안됨
- 유저의 ROLE 구분을 어떻게 할지? 유저 엔티티안에 넣기, role별 컬렉션에 user._id 넣기
  - role 컬렉션을 따로 넣는다면?
    - 한 유저가 두 역할을 갖고있을 경우 중복 요청 필요
    - 새로운 역할을 추가 할 경우, 컬렉션뿐 아니라, 서비스, API 모두 늘어남
    - 사용자 목록을 조회 할 때, 컬렉션을 모두 순회해야 함
  - 유저 엔티티안에 넣는다면?
    - 유저가 다중 권한을 가지기 쉬움 (장점인가?)
    - 조회, 검색 모두 한 컬렉션에서 인덱스만 걸면 가능
    - 새로운 역할 도입 할 때, 스키마 변경 및 마이그레이션 부담 감소
    - 유저 문서가 커질 수 있음
    - 역할에 대한 메타 데이터를 담고있는 엔터티 필요
